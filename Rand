import os
import ctypes as ct
import sys
import csv
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QPushButton, QLabel, QLineEdit, QTextEdit, QMessageBox, QStackedWidget, QScrollArea

class LoginScreen(QWidget):
    def __init__(self, stacked_widget):
        super().__init__()
        self.stacked_widget = stacked_widget
        self.initUI()

    def initUI(self):
        # self.stacked_widget.setGeometry(50,50,400,300)
        self.stackedWidget = QStackedWidget()
        
        main_screen = QWidget()
        user_button = QPushButton('User', main_screen)
        admin_button = QPushButton('Admin', main_screen)

        user_button.clicked.connect(self.showUserScreen)
        admin_button.clicked.connect(self.passCheck)

        layout = QVBoxLayout(main_screen)
        layout.setSpacing(0)
        layout.setContentsMargins(0,0,0,0)
        layout.addWidget(QLabel('Choose user type:'))
        layout.addWidget(user_button)
        layout.addWidget(admin_button)
        
        self.stackedWidget.addWidget(main_screen)
        self.setLayout(QVBoxLayout(self))
        self.layout().addWidget(self.stackedWidget)

    def passCheck(self):
        self.stacked_widget.setCurrentIndex(1)

    def showUserScreen(self):
        self.stacked_widget.setCurrentIndex(2)

    def showAdminScreen(self):
        self.stacked_widget.setCurrentIndex(3)

class passCheck(QWidget):
    def __init__(self,stacked_widget):
        super().__init__()
        self.stacked_widget = stacked_widget
        self.initUI()

    def initUI(self):
        self.stackedWidget = QStackedWidget()

        main_screen = QWidget()
        passText = QLabel('Enter password:',main_screen)
        passEnter = QLineEdit(main_screen)
        passCheck_button = QPushButton('Log in',main_screen)
        back_button = QPushButton('Back',main_screen)

        passCheck_button.clicked.connect(lambda: self.checkPass(passEnter))
        back_button.clicked.connect(self.goBack)

        main_layout = QHBoxLayout(main_screen)
        main_layout.addWidget(passText)
        main_layout.addWidget(passEnter)
        main_layout.addWidget(passCheck_button)
        # main_layout.addWidget(back_button)

        self.stackedWidget.addWidget(main_screen)
        # self.stackedWidget.setCurrentWidget(main_screen)
        self.setLayout(QVBoxLayout(self))
        self.layout().addWidget(self.stackedWidget)

    def checkPass(self,passEnter):
        passEnter = passEnter.text().strip()
        if passEnter == "hehe":
            self.stacked_widget.setCurrentIndex(3)
        else:
            QMessageBox.critical(self, 'Error', 'Wrong Password. Try again')

    def goBack(self):
        self.stacked_widget.setCurrentIndex(0)


class UserScreen(QWidget):
    
    def __init__(self, stacked_widget):
        super().__init__()
        self.stacked_widget = stacked_widget
        self.dictionary = self.dictionaryCreate('english.csv')
        self.trie = self.make_trie(self.dictionary)
        self.initUI()

    def initUI(self):
        self.stackedWidget = QStackedWidget()

        # Main Screen
        main_screen = QWidget()
        get_button = QPushButton('Get Word', main_screen)
        back_button = QPushButton('Back', main_screen)
        
        get_button.clicked.connect(self.showGetScreen)
        back_button.clicked.connect(self.goBack)

        main_layout = QVBoxLayout(main_screen)
        main_layout.addWidget(get_button)

        self.stackedWidget.addWidget(main_screen)

        self.setLayout(QVBoxLayout(self))
        self.layout().addWidget(self.stackedWidget)

    def showGetScreen(self):
        get_screen = QWidget()
        word_entry = QLineEdit(get_screen)
        get_button = QPushButton('Get', get_screen)
        back_button = QPushButton('Back', get_screen)
        output_display = QTextEdit(get_screen)

        get_button.clicked.connect(lambda: self.getWord(word_entry, output_display))
        back_button.clicked.connect(lambda: self.stackedWidget.setCurrentIndex(0))

        get_layout = QVBoxLayout(get_screen)
        get_layout.addWidget(QLabel('Word:'))
        get_layout.addWidget(word_entry)
        get_layout.addWidget(get_button)
        get_layout.addWidget(back_button)
        get_layout.addWidget(output_display)

        self.stackedWidget.addWidget(get_screen)
        self.stackedWidget.setCurrentWidget(get_screen)

    def dictionaryCreate(self, filename):
        dictionary = {}
        try:
            countX = 127338
            countY = 139824
            with open(filename) as f:
                data = f.readlines()
            for i in range(len(data)):
                if i >= countX and i <= countY:
                    data[i] = data[i].strip().split(' ')
                else:
                    #User-defined words from 188510
                    data[i] = data[i].strip().split(',')
            
            for i in range(1,len(data)):
                word = data[i].pop(0)
                word = word.upper()
                if word in dictionary:
                    dictionary[word].append(','.join(data[i]))
                else:
                    dictionary[word] = [','.join(data[i])]
        except FileNotFoundError:
            QMessageBox.critical(self, 'Error', f'Could not find {filename}. Please make sure the file exists.')
        return dictionary

    def make_trie(self, dictionary):
        trie = {}
        for word in dictionary:
            current_dict = trie
            for letter in word:
                if letter not in current_dict:
                    current_dict[letter] = {}
                current_dict = current_dict[letter]
            current_dict["_end"] = dictionary[word]
        return trie

    def getWord(self, word_entry, output_display):
        word = word_entry.text().strip().upper()
        result = self.in_trie(self.trie, word, self.dictionary)
        output_display.setText(result)

    def in_trie(self, trie, word, dictionary):
        current_dict = trie
        for letter in word:
            if letter not in current_dict:
                return "No such word in dictionary."
            current_dict = current_dict[letter]
        if "_end" in current_dict:
            meanings = ', '.join(current_dict["_end"])
            return f"{word}: {meanings}"
        else:
            return "No meanings found for this word in dictionary."

    def goBack(self):
        self.stacked_widget.setCurrentIndex(0)

class AdminScreen(QWidget):
    
    def __init__(self, stacked_widget):
        super().__init__()
        self.stacked_widget = stacked_widget
        self.dictionary = self.dictionaryCreate('english.csv')
        self.trie = self.make_trie(self.dictionary)
        self.currentWord = ''
        self.initUI()

    def initUI(self):
        self.stackedWidget = QStackedWidget()

        # Main Screen
        main_screen = QWidget()
        insert_button = QPushButton('Insert Word', main_screen)
        get_button = QPushButton('Get Word', main_screen)
        delete_button = QPushButton('Delete Word', main_screen)
        reset_button = QPushButton('Reset Dictionary', main_screen)
        get_letter_button = QPushButton('Get Word Letter-by-letter',main_screen)
        delete_meaning_button = QPushButton('Delete Meaning of Word',main_screen)
        back_button = QPushButton('Back',main_screen)
        
        insert_button.clicked.connect(self.showInsertScreen)
        get_button.clicked.connect(self.showGetScreen)
        delete_button.clicked.connect(self.showDeleteScreen)
        reset_button.clicked.connect(self.resetDictionary)
        get_letter_button.clicked.connect(self.getLetterScreen)
        delete_meaning_button.clicked.connect(self.ShowDeleteMeaningScreen)
        back_button.clicked.connect(self.goBack)

        main_layout = QVBoxLayout(main_screen)
        main_layout.addWidget(reset_button)
        main_layout.addWidget(insert_button)
        main_layout.addWidget(get_button)
        main_layout.addWidget(get_letter_button)
        main_layout.addWidget(delete_button)
        main_layout.addWidget(delete_meaning_button)

        self.stackedWidget.addWidget(main_screen)

        self.setLayout(QVBoxLayout(self))
        self.layout().addWidget(self.stackedWidget)

    def showInsertScreen(self):
        insert_screen = QWidget()
        word_entry = QLineEdit(insert_screen)
        verb_entry = QLineEdit(insert_screen)
        meaning_entry = QTextEdit(insert_screen)
        insert_button = QPushButton('Insert', insert_screen)
        back_button = QPushButton('Back', insert_screen)
        output_display = QLabel(insert_screen)

        scroll_area = QScrollArea(insert_screen)
        scroll_area.setWidgetResizable(True)  # Ensure the widget inside the scroll area resizes with the scroll area
        scroll_area.setWidget(output_display)

        insert_button.clicked.connect(lambda: self.insertWord(word_entry, verb_entry, meaning_entry, output_display))
        back_button.clicked.connect(lambda: self.stackedWidget.setCurrentIndex(0))

        insert_layout = QVBoxLayout(insert_screen)
        insert_layout.addWidget(QLabel('Word:'))
        insert_layout.addWidget(word_entry)
        insert_layout.addWidget(QLabel('Verb:'))
        insert_layout.addWidget(verb_entry)
        insert_layout.addWidget(QLabel('Meaning:'))
        insert_layout.addWidget(meaning_entry)
        insert_layout.addWidget(insert_button)
        insert_layout.addWidget(back_button)
        insert_layout.addWidget(QLabel('Output:'))
        insert_layout.addWidget(scroll_area)

        self.stackedWidget.addWidget(insert_screen)
        self.stackedWidget.setCurrentWidget(insert_screen)

    def showGetScreen(self):
        get_screen = QWidget()
        word_entry = QLineEdit(get_screen)
        get_button = QPushButton('Get', get_screen)
        back_button = QPushButton('Back', get_screen)
        output_display = QLabel(get_screen)

        scroll_area = QScrollArea(get_screen)
        scroll_area.setWidgetResizable(True)  # Ensure the widget inside the scroll area resizes with the scroll area
        scroll_area.setWidget(output_display)

        get_button.clicked.connect(lambda: self.getWord(word_entry, output_display))
        back_button.clicked.connect(lambda: main())

        get_layout = QVBoxLayout(get_screen)
        get_layout.addWidget(QLabel('Word:'))
        get_layout.addWidget(word_entry)
        get_layout.addWidget(get_button)
        get_layout.addWidget(back_button)
        get_layout.addWidget(QLabel('Output:'))
        get_layout.addWidget(scroll_area)

        self.stackedWidget.addWidget(get_screen)
        self.stackedWidget.setCurrentWidget(get_screen)

    def showDeleteScreen(self):
        delete_screen = QWidget()
        word_entry = QLineEdit(delete_screen)
        delete_button = QPushButton('Delete', delete_screen)
        back_button = QPushButton('Back', delete_screen)
        output_display = QLabel(delete_screen)

        scroll_area = QScrollArea(delete_screen)
        scroll_area.setWidgetResizable(True)  # Ensure the widget inside the scroll area resizes with the scroll area
        scroll_area.setWidget(output_display)

        delete_button.clicked.connect(lambda: self.deleteWord(word_entry, output_display))
        back_button.clicked.connect(lambda: self.stackedWidget.setCurrentIndex(0))

        delete_layout = QVBoxLayout(delete_screen)
        delete_layout.addWidget(QLabel('Word:'))
        delete_layout.addWidget(word_entry)
        delete_layout.addWidget(delete_button)
        delete_layout.addWidget(back_button)
        delete_layout.addWidget(QLabel('Output:'))
        delete_layout.addWidget(scroll_area)

        self.stackedWidget.addWidget(delete_screen)
        self.stackedWidget.setCurrentWidget(delete_screen)
    
    def ShowDeleteMeaningScreen(self):
        delete_meaning_screen = QWidget()
        word_entry = QLineEdit(delete_meaning_screen)
        meaning_entry = QLineEdit(delete_meaning_screen)
        verb_entry = QLineEdit(delete_meaning_screen)
        delete_button = QPushButton('Delete', delete_meaning_screen)
        back_button = QPushButton('Back', delete_meaning_screen)
        output_display = QTextEdit(delete_meaning_screen)

        delete_button.clicked.connect(lambda: self.deleteMeaning(word_entry, verb_entry, meaning_entry , output_display))
        back_button.clicked.connect(lambda: self.stackedWidget.setCurrentIndex(0))

        delete_layout = QVBoxLayout(delete_meaning_screen)
        delete_layout.addWidget(QLabel('Word:'))
        delete_layout.addWidget(word_entry)
        delete_layout.addWidget(QLabel('Verb:'))
        delete_layout.addWidget(verb_entry)
        delete_layout.addWidget(QLabel('Meaning:'))
        delete_layout.addWidget(meaning_entry)
        delete_layout.addWidget(delete_button)
        delete_layout.addWidget(back_button)
        delete_layout.addWidget(output_display)

        self.stackedWidget.addWidget(delete_meaning_screen)
        self.stackedWidget.setCurrentWidget(delete_meaning_screen)

    def deleteMeaning(self, word_entry, verb_entry, meaning_entry, output_display):
        word = word_entry.text().strip().upper()
        verb = verb_entry.text().strip()
        meaning = meaning_entry.text().strip()
        result = self.delete_trie_meaning(self.trie, word, verb, meaning, self.dictionary)
        output_display.setText(result) 

    def getLetterScreen(self):
        getLetter_screen = QWidget()

        # Create widgets
        letter_entry = QLineEdit(getLetter_screen)
        getLetter_button = QPushButton('Get words with letter', getLetter_screen)
        getFinalWord_button = QPushButton('Get meaning of the word', getLetter_screen)
        back_button = QPushButton('Back', getLetter_screen)
        output_display = QLabel(getLetter_screen)
        
        # Create a scroll area to contain the output label
        scroll_area = QScrollArea(getLetter_screen)
        scroll_area.setWidgetResizable(True)  # Ensure the widget inside the scroll area resizes with the scroll area
        scroll_area.setWidget(output_display)  # Set the output label as the widget in the scroll area

        output_display.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        # Connect buttons to slots
        getLetter_button.clicked.connect(lambda: self.getLetterWord(letter_entry, output_display))
        getFinalWord_button.clicked.connect(lambda: self.finalWord(output_display))
        back_button.clicked.connect(lambda: self.delete_clicked())

        # Create layout
        get_letter_layout = QVBoxLayout(getLetter_screen)
        get_letter_layout.addWidget(QLabel('Letter:'))
        get_letter_layout.addWidget(letter_entry)
        get_letter_layout.addWidget(getLetter_button)
        get_letter_layout.addWidget(getFinalWord_button)
        get_letter_layout.addWidget(back_button)
        get_letter_layout.addWidget(QLabel('Output'))
        get_letter_layout.addWidget(scroll_area)  # Add the scroll area to the layout

        # Add screen to stacked widget
        self.stackedWidget.addWidget(getLetter_screen)
        self.stackedWidget.setCurrentWidget(getLetter_screen)



    def dictionaryCreate(self, filename):
        dictionary = {}
        try:
            countX = 127338
            countY = 139824
            with open(filename) as f:
                data = f.readlines()
            for i in range(len(data)):
                if i >= countX and i <= countY:
                    data[i] = data[i].strip().split(' ')
                else:
                    #User-defined words from 188510
                    data[i] = data[i].strip().split(',')
            
            for i in range(1,len(data)):
                word = data[i].pop(0)
                word = word.upper()
                if word in dictionary:
                    dictionary[word].append(','.join(data[i]))
                else:
                    dictionary[word] = [','.join(data[i])]
        except FileNotFoundError:
            QMessageBox.critical(self, 'Error', f'Could not find {filename}. Please make sure the file exists.')
        return dictionary

    def make_trie(self, dictionary):
        trie = {}
        for word in dictionary:
            current_dict = trie
            for letter in word:
                if letter not in current_dict:
                    current_dict[letter] = {}
                current_dict = current_dict[letter]
            current_dict["_end"] = dictionary[word]
        return trie

    def insertWord(self, word_entry, verb_entry, meaning_entry, output_display):
        word = word_entry.text().strip().upper()
        verb = verb_entry.text().strip()
        meaning = meaning_entry.toPlainText().strip()
        
        if word == '' or meaning == '':
            output_display.setText('Word and meaning cannot be empty.')
            return
        
        result = self.insert_trie(self.trie, word, meaning, verb, self.dictionary)
        output_display.setText(result)

    def insert_trie(self, trie, word, meaning, verb, dictionary):
        current_dict = trie
        for letter in word:
            if letter not in current_dict:
                current_dict[letter] = {}
            current_dict = current_dict[letter]
        toBeAppended = verb + "," + meaning
        if "_end" in current_dict:
            if toBeAppended not in current_dict["_end"]:
                current_dict["_end"].append(toBeAppended)
                self.writeToCSV(word, verb, meaning)
                return "Meaning added successfully"
            else:
                return "Meaning already in dictionary!"
        else:
            current_dict["_end"] = [toBeAppended]
            self.writeToCSV(word, verb, meaning)
            return "Word entered successfully"

    def writeToCSV(self, word, verb, meaning):
        try:
            with open("english.csv", "a", newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow([word, verb, meaning])
        except FileNotFoundError:
            QMessageBox.critical(self, 'Error', 'CSV file not found.')

    def getWord(self, word_entry, output_display):
        word = word_entry.text().strip().upper()
        result = self.in_trie(self.trie, word, self.dictionary)
        output_display.setText(result)

    def in_trie(self, trie, word, dictionary):
        current_dict = trie
        for letter in word:
            if letter not in current_dict:
                return "No such word in dictionary."
            current_dict = current_dict[letter]
        if "_end" in current_dict:
            meanings = ', '.join(current_dict["_end"])
            return f"{word}: {meanings}"
        else:
            return "No meanings found for this word in dictionary."
        
    def in_trie_by_letter(self, trie, currentWord, dictionary):
        temp = currentWord.upper()
        current_dict = trie
        for letter in temp:
            if letter not in current_dict:
                return "No such words in dictionary that contain the following letters."
            current_dict = current_dict[letter]
        lst = list()
        for i in current_dict:
            if i == "_end":
                continue
            lst.append(currentWord+i.lower())
        return lst

    def deleteWord(self, word_entry, output_display):
        word = word_entry.text().strip().upper()
        result = self.delete_trie_word(self.trie, word, self.dictionary)
        output_display.setText(result)

    def delete_trie_word(self, trie, word, dictionary):
        current_dict = trie
        for letter in word:
            if letter not in current_dict:
                return "No such word in dictionary."
            current_dict = current_dict[letter]
        if "_end" not in current_dict:
            return "No such word in dictionary."
        else:
            del current_dict["_end"]
            self.delete_word_from_CS(word)
            return "Word removed successfully."

    def delete_word_from_CS(self, word):
        try:
            with open("english.csv", "r", newline='', encoding='utf-8') as copyf, open("transfer.csv", "w", newline='', encoding='utf-8') as f:
                reader = csv.reader(copyf)
                writer = csv.writer(f)
                for row in reader:
                    if row[0].strip().upper() != word:
                        writer.writerow(row)
            os.replace("transfer.csv", "english.csv")
        except FileNotFoundError:
            QMessageBox.critical(self, 'Error', 'CSV file not found.')
    
    def delete_trie_meaning(self, trie, word, verb, meaning , dictionary):
        current_dict = trie
        for letter in word:
            if letter not in current_dict:
                return "No such word in dictionary."
            current_dict = current_dict[letter]
        if "_end" not in current_dict:
            return "No such word in dictionary."
        else:
            for i in range(len(current_dict["_end"])):
                check = f"{verb.text().strip()},{meaning.text().strip()}"
                if check == current_dict["_end"][i]:
                    del current_dict["_end"][i]
                    self.delete_meaning_from_CSV(word,verb,meaning,dictionary,trie)
                    return "Meaning successfully deleted."
            return "No such meaning exists."
        
    def delete_meaning_from_CSV(self, word, verb, meaning, dictionary, trie):
        try:
            with open("english.csv", "r", newline='', encoding='utf-8') as copyf, open("transfer.csv", "w", newline='', encoding='utf-8') as f:
                csv.field_size_limit(int(ct.c_ulong(-1).value // 2))
                reader = csv.reader(copyf)
                writer = csv.writer(f)
                for row in reader:
                    if word == row[0].strip().upper() and verb.text().strip() == row[1] and meaning.text().strip() == row[2]:
                        pass
                    else:
                        writer.writerow(row)
            os.replace("transfer.csv", "english.csv")
        except FileNotFoundError:
            QMessageBox.critical(self, 'Error', 'CSV file not found.')

    def resetDictionary(self):
            try:
                with open("english.csv","w",newline='') as f:
                    writer = csv.writer(f)
                    with open("original.csv","r") as copyf:
                        csv.field_size_limit(int(ct.c_ulong(-1).value // 2))
                        reader = csv.reader(copyf)
                        for i, rows in enumerate(reader):
                            writer.writerow([rows[0],rows[1],rows[2]])
                self.dictionary = self.dictionaryCreate("english.csv")
                self.trie = self.make_trie(self.dictionary)
                QMessageBox.information(self, 'Success', 'Dictionary reset successfully.')
            except FileNotFoundError:
                QMessageBox.critical(self, 'Error', 'Original CSV file not found.')
    
    def delete_clicked(self):
        self.stackedWidget.setCurrentIndex(0)
        self.currentWord = ''

    def getLetterWord(self,letter_entry,output_display):
        letter_entry = letter_entry.text().strip()
        if len(letter_entry) > 1:
            output_display.setText("Invalid input. Enter one letter at a time.")
        else:
            self.currentWord += letter_entry
            letter_entry = self.currentWord
            result = self.in_trie_by_letter(self.trie,letter_entry,self.dictionary)
            if "No such words" in result:
                output_display.setText(result)
                self.currentWord = ''
            else:
                result = ", ".join(result)
                output_display.setText(result)

    def finalWord(self,output_display):
        temp = self.currentWord.upper()
        result = self.in_trie(self.trie,temp,self.dictionary)
        self.currentWord = ''
        output_display.setText(result)

    def goBack(self):
        self.stacked_widget.setCurrentIndex(0)

def main():
    app = QApplication(sys.argv)
    stacked_widget = QStackedWidget()

    login_screen = LoginScreen(stacked_widget)
    pass_check = passCheck(stacked_widget)
    user_screen = UserScreen(stacked_widget)
    admin_screen = AdminScreen(stacked_widget)

    stacked_widget.addWidget(login_screen)
    stacked_widget.addWidget(pass_check)
    stacked_widget.addWidget(user_screen)
    stacked_widget.addWidget(admin_screen)

    stacked_widget.setWindowTitle('Dictionary Application')
    stacked_widget.setGeometry(100, 100, 800, 600)
    stacked_widget.show()

    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
